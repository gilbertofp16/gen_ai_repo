<IMPORTANT_RULES source="Clean Code by Robert C. Martin">
  <CRITICAL>
    <PRINCIPLE priority="1">Never assume missing context — ask clarifying questions if uncertain. (Clean Code: “Don’t guess – clarify” — Robert C. Martin)</PRINCIPLE>
    <PRINCIPLE priority="2">Never hallucinate libraries or functions — use only known, verified packages. (Clean Code: “Avoid disinformation” — Robert C. Martin)</PRINCIPLE>
    <PRINCIPLE priority="3">Always confirm file paths and module names exist before referencing them.</PRINCIPLE>
    <PRINCIPLE priority="4">Always look at available code and suggest reuse of existing utilities if appropriate. (Clean Code: “Don’t repeat yourself (DRY)” — Robert C. Martin)</PRINCIPLE>
    <PRINCIPLE priority="5">Always mention which Cursor rules you applied in each response.</PRINCIPLE>
    <PRINCIPLE priority="6">Always generate accompanying unit tests (e.g. pytest) for any non-trivial code. (Clean Code: “Clean tests are first-class citizens” — Robert C. Martin)</PRINCIPLE>
    <PRINCIPLE priority="7">Mock test data according to actual data structures. If mock data is reusable, extract it to a shared module or file.</PRINCIPLE>
    <PRINCIPLE priority="8">Always validate input and output structures when dealing with APIs or endpoints. This applies across all programming languages.</PRINCIPLE>
    <PRINCIPLE priority="9">Confirm external dependencies: verify the latest stable version and import path before use.</PRINCIPLE>
    <PRINCIPLE priority="10">Surface performance considerations: note time and space complexity for algorithmic code. (Clean Code: “Consider efficiency, but clarity first” — Robert C. Martin)</PRINCIPLE>
    <PRINCIPLE priority="11">Always outline your error handling strategy before coding. (Clean Code: “Error handling is one thing” — Robert C. Martin)</PRINCIPLE>
    <PRINCIPLE priority="12">Echo the minimal file or directory structure when referring to paths.</PRINCIPLE>
    <PRINCIPLE priority="13">Execute all tasks with the proficiency of a senior software developer in the target language.</PRINCIPLE>
    <PRINCIPLE priority="14">Never expose, log, or consume API keys, secrets, or .env variables in code, tests, or documentation. Always use environment variable mocking or secure injection for testing.</PRINCIPLE>
    <PRINCIPLE priority="15">CLINE must respect .clineignore and never read, parse, or suggest the contents of ignored files such as .env, secrets, or credentials.</PRINCIPLE>
  </CRITICAL>

  <ENFORCEMENT>
    <RULE>All rules are mandatory unless explicitly overridden by user instruction.</RULE>
    <RULE>Rules take precedence over conversational guidance or suggestions.</RULE>
  </ENFORCEMENT>

  <CODING_RULES>
    <GENERAL>
      <RULE id="GEN001">Follow Clean Code principles (Robert C. Martin): meaningful names, small functions, single responsibility, avoid duplication (DRY), expressive tests, clear formatting.</RULE>
      <RULE id="GEN002"><![CDATA[
        Adhere to SOLID principles (Robert C. Martin):
        1. Single Responsibility – one reason to change per module, class, or function.
        2. Open/Closed – open for extension, closed for modification.
        3. Liskov Substitution – subtypes replace base types without altering correctness.
        4. Interface Segregation – many focused interfaces over one large interface.
        5. Dependency Inversion – depend on abstractions, not concretes.
      ]]></RULE>
      <RULE id="GEN003">If your code interacts with endpoints, always define and enforce data structures for request and response validation.</RULE>
      <RULE id="GEN004">Never hardcode or directly consume API keys or values from .env files in examples, tests, or code snippets. Always mock or safely inject them to prevent exposure.</RULE>
      <RULE id="GEN005">Minimal exception scope. Do not wrap imports or trivial statements in try except. Catch the narrowest exception only where you handle or transform it. Re-raise after adding context rather than swallowing errors.</RULE>
      <RULE id="GEN006"><![CDATA[
        Dependency import policy:
        A) Required dependencies MUST be imported unconditionally at module import with no try/except.
        B) Optional dependencies MUST be imported inside the function or method that needs them.
           On absence, catch ModuleNotFoundError ONLY at that point and raise RuntimeError with a short install hint.
        C) PROHIBITED patterns:
           - try/except around required imports (e.g., yaml, requests, crewai, langchain in this repo).
           - Setting a missing module variable to None or creating stub objects.
           - Printing warnings or logging and continuing after an ImportError.
      ]]></RULE>
      <RULE id="GEN007">Do not hardcode descriptive strings for agents, roles, prompts, or goals in code. Load from configuration (YAML, JSON, or TOML) and reference parsed values or constants from config modules.</RULE>
      <RULE id="GEN008">No silent degradation. Missing required capabilities must fail fast with a precise exception. Do not print warnings, do not continue with partial functionality, do not create placeholder modules or values.</RULE>
      <RULE id="GEN009">Use descriptive file names that clearly indicate the file's purpose and contents. Avoid generic names such as `utils.py` or `files.py`.</RULE>
      <RULE id="GEN010">Testing strategy: Prefer outside-in tests and minimise mocking; mock only true external boundaries (HTTP, DB, queues, time), never internal helpers or orchestration, and assert on observable outcomes rather than implementation details.</RULE>    
    </GENERAL>

    <PYTHON>
      <RULE id="PY001">Avoid code comments. Functions should be self documenting with expressive names.</RULE>
      <RULE id="PY002">Decompose complex logic. Each function should have a single responsibility.</RULE>
      <RULE id="PY003">Use PEP 257 docstrings on every public class or function.</RULE>
      <RULE id="PY004">Enforce type hints on all function signatures.</RULE>
      <RULE id="PY005">One logical statement per line. No chained assignments or multiple expressions per line.</RULE>
      <RULE id="PY006">Fail fast with clear exceptions. Validate inputs at entry and raise precise ValueError or custom exceptions.</RULE>
      <RULE id="PY007">Prefer a single exit point per function where practical.</RULE>
      <RULE id="PY008">Prefer pure functions. Isolate side effects into clearly named wrappers.</RULE>
      <RULE id="PY009">Always include a See also section in docstrings linking to related utilities or modules.</RULE>
      <RULE id="PY010">Group related functions into modules rather than monolithic files.</RULE>
      <RULE id="PY011">Limit method signatures to at most three parameters. Inject dependencies rather than using global state.</RULE>
      <RULE id="PY012">Format code with Black using a maximum line length of 120 characters.</RULE>
      <RULE id="PY013">Use Poetry for dependency management and virtual environments.</RULE>
      <RULE id="PY014">Follow a Cookiecutter style project layout with src, tests, pyproject.toml, README.md, and docs.</RULE>
      <RULE id="PY015">In pytest tests, mock data structures to match real usage. Extract reusable mocks into shared test utilities.</RULE>
      <RULE id="PY016">Top level code policy. Only allow constants, dataclasses, type aliases, logger setup, and trivial configuration constants. No I/O, network calls, file reads, event loops, heavy computations, or client construction at import time.</RULE>
      <RULE id="PY017">Import policy. Required dependencies are imported unconditionally. Do not wrap required imports in try except. Verify import paths against the actual project tree before referencing.</RULE>
      <RULE id="PY018">Main guard. All executable logic must live under if __name__ == "__main__": or inside functions or classes. Provide a small main() and call it from the guard. Tests and CLIs must call functions, not run logic at import time.</RULE>
      <RULE id="PY019">Async boundaries. Do not call asyncio.run at import time or inside lambdas defined at import time. Provide small sync adapters inside functions or main guard when bridging sync and async code.</RULE>
      <RULE id="PY020">Config and file access. Reading YAML or other config files happens inside functions and is parameterizable by path. Lazy cache results only inside those functions. Never perform file I/O at import time.</RULE>
      <RULE id="PY021">Globals discipline. Allowed: LOGGER, DEFAULTS, TypedDict or dataclass definitions, simple constants, dependency tokens. Prohibited: constructed clients such as LLMs, DB engines, or tool instances at import time. Use factory functions instead.</RULE>
      <RULE id="PY022">Tool factories. Any CrewAI or LangChain tool or agent must be created by a factory function so creation side effects are explicit and testable. Do not instantiate tools at import time.</RULE>
      <RULE id="PY023">Error handling strategy first. For any function touching I/O or external systems, list expected failures and how each is surfaced. Keep try except around only the minimal failing lines. Raise precise, contextual exceptions.</RULE>
      <RULE id="PY024">Testable structure. Provide small adapters for side effects so unit tests can mock them. No top level execution paths. Include pytest cases for factories and adapters.</RULE>
    </PYTHON>

    <JAVASCRIPT>
      <RULE id="JS001">Use Prettier and ESLint with a consistent configuration.</RULE>
      <RULE id="JS002">Enforce type safety with TypeScript. No implicit any and prefer strict mode.</RULE>
      <RULE id="JS003">Use ES module syntax for imports and exports whenever possible.</RULE>
      <RULE id="JS004">Write small pure functions. Separate side effects into well named services or hooks.</RULE>
      <RULE id="JS005">Scaffold projects via a Cookiecutter like tool or create node package.</RULE>
      <RULE id="JS006">Write unit tests with Jest or Mocha with high coverage and meaningful cases.</RULE>
      <RULE id="JS007">Follow Clean Code JS best practices for naming, error handling, and formatting.</RULE>
    </JAVASCRIPT>
  </CODING_RULES>
</IMPORTANT_RULES>
